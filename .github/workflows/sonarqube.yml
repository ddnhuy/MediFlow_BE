name: SonarQube

on:
  push:
    branches:
      - develop
  pull_request:
    branches:
      - develop
    types: [opened, synchronize, reopened]

jobs:
  build:
    name: Build, test and analyze
    runs-on: ubuntu-latest

    steps:
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: 17
          distribution: "zulu"

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important for SonarQube to get all history

      - name: Cache SonarQube Cloud packages
        uses: actions/cache@v4
        with:
          path: ~/.sonar/cache
          key: ${{ runner.os }}-sonar
          restore-keys: ${{ runner.os }}-sonar

      - name: Cache SonarQube Cloud scanner
        id: cache-sonar-scanner
        uses: actions/cache@v4
        with:
          path: ./.sonar/scanner
          key: ${{ runner.os }}-sonar-scanner
          restore-keys: ${{ runner.os }}-sonar-scanner

      - name: Install SonarQube Cloud scanner
        if: steps.cache-sonar-scanner.outputs.cache-hit != 'true'
        shell: bash
        run: |
          mkdir -p ./.sonar/scanner
          dotnet tool update dotnet-sonarscanner --tool-path ./.sonar/scanner

      - name: Restore NuGet packages
        shell: bash
        run: dotnet restore MediFlow.sln

      - name: Set up Docker
        uses: docker/setup-buildx-action@v3

      - name: Pull PostgreSQL image
        shell: bash
        run: docker pull postgres:14

      - name: Build and start Docker Compose
        run: docker compose -f ./docker-compose.yml -f ./docker-compose.override.yml up -d

      # Add a delay to ensure services are fully started
      - name: Wait for services to be ready
        run: sleep 20

      # Begin SonarQube analysis after Docker is ready but before tests
      - name: Begin SonarQube analysis
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          ./.sonar/scanner/dotnet-sonarscanner begin \
            /k:"ddnhuy_MediFlow_BE" \
            /o:"ddnhuy" \
            /d:sonar.token="${SONAR_TOKEN}" \
            /d:sonar.host.url="https://sonarcloud.io" \
            /d:sonar.cs.opencover.reportsPaths="TestResults/*.opencover.xml" \
            /d:sonar.cs.vstest.reportsPaths="TestResults/*.trx" \
            /d:sonar.exclusions="**/appsettings*.json,**/SeedData.cs,**/helm/**/*,**/Migrations/**/*,**/obj/**/*,**/bin/**/*" \
            /d:sonar.coverage.exclusions="**/*Test*.cs,**/*Test*/*.cs,**/Test*/**/*.cs,**/Migrations/**/*,**/*.Dto.cs,**/*.Dto/*.cs,**/*.Model.cs,**/*.Models/*.cs" \
            /d:sonar.verbose=true

      - name: Build the project
        shell: bash
        run: |
          echo "Building solution..."
          dotnet build MediFlow.sln --no-restore --configuration Release
          
          # Cài đặt các công cụ coverage nếu cần
          dotnet add package coverlet.collector --version 6.0.0
          dotnet add package coverlet.msbuild --version 6.0.0

      # Run tests with consistent coverage format
      - name: Run tests with coverage
        shell: bash
        run: |
          # Cài đặt coverlet
          dotnet tool install --global coverlet.console
          
          # Tạo thư mục cho báo cáo
          mkdir -p TestResults
          rm -rf TestResults/*
          
          # Tìm tất cả các project test
          test_projects=$(find . -name "*Test*.csproj" -o -name "*Tests.csproj")
          
          # Chạy test cho từng project với coverage
          echo "=== Running tests with coverage reports ==="
          for proj in $test_projects; do
            echo "Testing project: $proj"
            project_name=$(basename "$proj" .csproj)
            
            # Chạy dotnet test với coverlet
            dotnet test "$proj" \
              --configuration Release \
              --no-build \
              --no-restore \
              --logger "trx;LogFileName=TestResults/$project_name.trx" \
              /p:CollectCoverage=true \
              /p:CoverletOutputFormat="opencover" \
              /p:CoverletOutput="TestResults/$project_name.opencover.xml" \
              /p:Exclude="[*]*Migrations*,[*]*SeedData*,[*]*.Dto,[*]*.Models" \
              || echo "Tests may have failed for $project_name but continuing"
          done
          
          # Hiển thị danh sách file được tạo
          echo "=== Coverage files generated ==="
          find TestResults -type f | sort
          
          # Kiểm tra file coverage có tồn tại không
          coverage_files=$(find TestResults -name "*.opencover.xml" | wc -l)
          if [ "$coverage_files" -eq 0 ]; then
            echo "WARNING: No coverage files were generated!"
            
            # Tạo file coverage rỗng để tránh lỗi
            echo '<?xml version="1.0" encoding="utf-8"?><CoverageSession></CoverageSession>' > TestResults/empty.opencover.xml
          else
            echo "Found $coverage_files coverage files."
          fi

      - name: End SonarQube analysis
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        shell: bash
        run: |
          echo "Coverage files being sent to SonarQube:"
          find TestResults -name "*.opencover.xml" -type f | xargs ls -la
          
          echo "Sending analysis to SonarQube..."
          ./.sonar/scanner/dotnet-sonarscanner end /d:sonar.token="${SONAR_TOKEN}" || echo "SonarQube analysis may have issues but workflow continues"

      # Upload coverage reports as artifacts for debugging 
      - name: Upload coverage report as artifact
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-reports
          path: TestResults
          retention-days: 1
          
      - name: Clean up Docker containers
        if: always()  # Ensure cleanup happens even if previous steps fail
        run: docker compose -f ./docker-compose.yml -f ./docker-compose.override.yml down